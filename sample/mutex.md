为了进行同步，我们往往会需要用锁，信号量，条件量。

## mutex

互斥锁对外提供两个操作,`Lock` 和 `Unlock` 。go的mutex是通过信号量实现的，实现一个toy互斥锁很简单。

```
type ToyMutex struct {
        state  int32
        sema uint32
}

func (tm *ToyMutex) Lock() {
        if atomic.AddInt32(&tm.state, 1) == 1 {
                return
        }
        runtime_Semacquire(&m.sema)
}

func (tm *ToyMutex) Unlock() {
        switch v := atomic.AddInt32(&m.state, -1); {
        case v == 0:
                return
        case v == -1:
                panic("sync: unlock of unlocked mutex")
        }
        runtime_Semrelease(&tm.sema)
}
```
这个就是玩具车，虽然能用，但是性能太低。下面来看一下go的超跑。
go的超跑考虑了下面几件事。
1. 唤醒顺序。多个协程等待锁时，该唤醒哪一个？
2. 自旋or挂起。如果很快就能得到锁，协程切换是不划算的。go的mutex会视情况自旋or挂起。

### 唤醒顺序
首先考虑第一个，多个协程等待锁，唤醒哪一个？这跟调度器差不多，本质是资源的合理分配。
说到资源的合理分配，就离不开公平和效率。
- 对于公平，很容易想到的方式就是先来先服务。
- 对于效率，最有效的就是后来先服务。(cpu的局部性)

公平和效率往往要相互妥协。go分为两种模式:
正常模式:如果等待的锁只有1个，进入正常模式。后来先服务。
饥饿模式:如果某个协程等待了1ms，进入饥饿模式。为先来先服务。
mutex源码中许多地方都在考虑资源如何合理分配。

### 自旋or挂起
合理的自旋是可以提高程序的性能。怎么才算合理？
1. 非饥饿模式。前面的协程快饿死了，就别添乱了。
2. 锁被其他协程持有。能拿到锁就别墨迹。
3. 只能自旋少于 4 次。大家都自旋对谁都不好。
4. 运行在多核机器上并且 GOMAXPROCS>1。就一个干活的就别自旋了，徒劳无功。
5. 最少有一个其它正在运行的 P。同上。
6. 本地的运行队列 runq 里没有 G 在等待。这个不太懂具体原因。

可以看出合理的要求还是很严格的。不合理的自旋会极大的降低程序的性能，如果不是专家，还是不建议自旋。

## 源码实现
说完了go的设计思想，下面就来看一下实现。为了区别，下面把state的最后一位称为资源。
说之前要提到一个问题。
资源的释放和协程的唤醒。
资源的释放是操作state，协程的唤醒是操作sema，
这是两个步骤，因此被唤醒的协程不一定可以获取资源，需要循环进行。
获取失败，则继续挂起(这有点像信号量，其实信号量也是这么实现的)。
(唤醒协程可以随意一些，比如一次全部唤醒了也ok，只不过会造成惊群效应。
但是获取释放资源必须要严格正确，不然就会死锁或者没限制住。)

1. 被唤醒的协程VS新来的协程。
接下来是具体实现
首先对于标志位可以放入state中，内存复用，提高性能。
但是这么做是难以阅读的，因此建议用struct代替提高阅读效率。
```
// 还是一个uint32，只是方便阅读。
type State struct{
    bool locked
    bool woken
    bool starving
    uint29 waiter
}
```
下面是具体代码。



















